import {
  useConfigurations,
  useWindowDimensions,
} from "./ResponsiveProvider.jsx";

export function getSortedEntries(sizes) {
  return Object.entries(sizes).sort((a, b) => a[1] - b[1]);
}

export function res(sizes, smoothScaling) {
  const { width } = useWindowDimensions();
  const config = useConfigurations();
  const bpSizes = config.sizes;
  const smooth = smoothScaling || config.smooth;

  const entries = getSortedEntries(bpSizes);

  let inputSizes = {};
  if (typeof sizes === "number") {
    entries.forEach((pair) => {
      const [key, value] = pair;
      inputSizes[key] = sizes;
    });
  } else {
    inputSizes = sizes;
  }

  let px;
  let bpSize;
  const notFound = entries.every((pair) => {
    const [key, value] = pair;
    if (width <= value) {
      px = inputSizes[key];
      bpSize = bpSizes[key];
      return false;
    }
    return true;
  });
  if (notFound) {
    const lastBP = entries[entries.length - 1];
    const lastKey = lastBP[0];
    return inputSizes[lastKey];
  }

  return smooth ? (px * width) / bpSize : px;
}

export function rem(sizes) {
  const rem = res(sizes) / 16;
  return `${rem}rem`;
}

export function oneOf(sizes) {
  const { width } = useWindowDimensions();
  const config = useConfigurations();
  const bpSizes = config.sizes;
  const entries = getSortedEntries(bpSizes);

  let response
  const notFound = entries.every(pair => {
    const [key, value] = pair;
    if (width <= value) {
      response = sizes[key];
      return false
    }
    return true
  });
  if (notFound) {
    const lastBP = entries[entries.length - 1];
    const lastKey = lastBP[0];
    return sizes[lastKey];
  }

  return response
}

export function px(sizes) {
  return `${res(sizes)}px`;
}

export function inBreakpoints(bps) {
  const { width } = useWindowDimensions();
  const config = useConfigurations();
  const bpSizes = config.sizes;
  const entries = getSortedEntries(bpSizes);

  let toReturn = false;
  let prev = 0;
  entries.every((pair) => {
    const [key, value] = pair;

    if (bps.includes(key)) {
      if (width <= value && width > prev) {
        toReturn = true;
        return false;
      }
    }
    prev = value;
    return true;
  });

  return toReturn;
}

export function inBreakpoint(bp) {
  return inBreakpoints([bp]);
}

export function isMax() {
  const { width } = useWindowDimensions();
  const config = useConfigurations();
  const bpSizes = config.sizes;
  const entries = getSortedEntries(bpSizes);
  const lastBP = entries[entries.length - 1];
  return width >= lastBP[1];
}
